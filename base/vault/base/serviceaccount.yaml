apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-auth
  namespace: vault
---
# base/vault/base/vault-init.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vault-init
  namespace: vault
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vault-init
  template:
    metadata:
      labels:
        app: vault-init
    spec:
      serviceAccountName: vault-init
      initContainers:
      - name: wait-for-vault
        image: busybox
        command: ['sh', '-c', 'until wget -q --spider http://vault-0.vault-internal:8200/v1/sys/health || wget -q --spider http://vault.vault.svc:8200/v1/sys/health; do echo waiting for vault; sleep 2; done;']
      containers:
      - name: vault-init
        image: hashicorp/vault:1.13.3
        command: ["/bin/sh"]
        args: ["/scripts/init.sh"]
        env:
        - name: VAULT_ADDR
          value: "http://vault.vault.svc:8200"
        - name: KUBERNETES_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: init-script
          mountPath: /scripts
          readOnly: true
        - name: vault-keys
          mountPath: /vault/keys
      volumes:
      - name: init-script
        configMap:
          name: vault-init-script
          defaultMode: 0755
      - name: vault-keys
        emptyDir: {}

---
# base/vault/base/vault-init-script.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-init-script
  namespace: vault
data:
  init.sh: |
    #!/bin/sh
    set -e

    # Function to save keys to Kubernetes secret
    save_keys() {
      local init_output=$1
      echo "$init_output" > /vault/keys/init-output.json

      # Extract root token and create secret
      ROOT_TOKEN=$(echo "$init_output" | grep 'Initial Root Token:' | awk '{print $NF}')
      kubectl -n $KUBERNETES_NAMESPACE create secret generic vault-token \
        --from-literal=token=$ROOT_TOKEN \
        --dry-run=client -o yaml | kubectl apply -f -

      # Create secret with unseal keys
      UNSEAL_KEYS=$(echo "$init_output" | grep 'Unseal Key' | awk '{print $NF}' | tr '\n' ' ')
      kubectl -n $KUBERNETES_NAMESPACE create secret generic vault-unseal-keys \
        --from-literal=keys="$UNSEAL_KEYS" \
        --dry-run=client -o yaml | kubectl apply -f -
    }

    # Check if Vault is initialized
    if ! vault status > /dev/null 2>&1; then
      echo "Initializing Vault..."
      INIT_OUTPUT=$(vault operator init)
      save_keys "$INIT_OUTPUT"
    fi

    # Get unseal keys
    UNSEAL_KEYS=$(kubectl get secret -n $KUBERNETES_NAMESPACE vault-unseal-keys -o jsonpath='{.data.keys}' | base64 -d)

    # Function to unseal vault
    unseal_vault() {
      local vault_addr=$1
      echo "Unsealing Vault at $vault_addr..."
      export VAULT_ADDR=$vault_addr

      if vault status | grep -q 'Sealed.*true'; then
        echo "$UNSEAL_KEYS" | tr ' ' '\n' | head -n 3 | while read key; do
          vault operator unseal $key
        done
      fi
    }

    # Unseal primary vault
    unseal_vault "http://vault-0.vault-internal:8200"

    # Join raft cluster for other pods
    for i in $(seq 1 2); do
      if [ -n "$(kubectl get pod vault-$i -n $KUBERNETES_NAMESPACE 2>/dev/null)" ]; then
        export VAULT_ADDR="http://vault-$i.vault-internal:8200"

        # Join raft cluster if not already joined
        if ! vault status > /dev/null 2>&1; then
          vault operator raft join "http://vault-0.vault-internal:8200"
        fi

        # Unseal the vault
        unseal_vault "http://vault-$i.vault-internal:8200"
      fi
    done

    # Configure Vault with root token
    export VAULT_ADDR="http://vault.vault.svc:8200"
    ROOT_TOKEN=$(kubectl get secret -n $KUBERNETES_NAMESPACE vault-token -o jsonpath='{.data.token}' | base64 -d)
    export VAULT_TOKEN=$ROOT_TOKEN

    # Enable and configure auth methods, policies, etc.
    vault auth enable kubernetes || true

    vault write auth/kubernetes/config \
      kubernetes_host="https://kubernetes.default.svc" \
      token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
      kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
      issuer="https://kubernetes.default.svc.cluster.local"

    # Create policies
    vault policy write oauth-policy - <<EOF
    path "kv/data/oauth2-proxy/*" {
      capabilities = ["read", "list"]
    }
    path "kv/metadata/oauth2-proxy/*" {
      capabilities = ["list"]
    }
    EOF

    # Create roles
    vault write auth/kubernetes/role/oauth2-proxy \
      bound_service_account_names=oauth2-proxy \
      bound_service_account_namespaces=oauth \
      policies=oauth-policy \
      ttl=1h

    # Enable secrets engines
    vault secrets enable -path=kv -version=2 kv || true

    # Keep the pod running to maintain unsealed state
    tail -f /dev/null

---
